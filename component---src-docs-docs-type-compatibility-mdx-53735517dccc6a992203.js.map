{"version":3,"sources":["webpack:///../src/docs/docs/type-compatibility.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","type","parentName","isMDXComponent"],"mappings":"6cAOO,IAAMA,EAAe,Q,sNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,sBADR,sBAGA,uBACA,6NACA,iBAAQ,CACN,GAAM,uCADR,wCAGA,mEAEA,YAAC,IAAD,CAAQC,KAAK,YAAYD,QAAQ,WACjC,oLACA,uBAAK,sBAAME,WAAW,OAAU,CAC5B,UAAa,wBADZ,kTAcL,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,scAiBL,iBAAQ,CACN,GAAM,gCADR,gCAGA,iSAC2K,mBAAGA,WAAW,KAAQ,CAC7L,KAAQ,mFAD+J,iBAD3K,qBAGgD,mBAAGA,WAAW,KAAQ,CAClE,KAAQ,mFADoC,aAHhD,eAMA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qqBAgBL,iBAAQ,CACN,GAAM,0BADR,0BAGA,kMACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,uBADZ,qGAUL,2FACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qdAUL,qCAAoB,0BAAYA,WAAW,KAAvB,aAApB,6DACA,kSACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,wMAML,iBAAQ,CACN,GAAM,aADR,aAGA,oIACA,iFAAgE,mBAAGA,WAAW,KAAQ,CAClF,KAAQ,gCADoD,kBAAhE,KAEiC,mBAAGA,WAAW,KAAQ,CACnD,KAAQ,6BADqB,WAFjC,KAI0B,mBAAGA,WAAW,KAAQ,CAC5C,KAAQ,0BADc,OAJ1B,+IAQA,8BACE,iBAAGA,WAAW,cAAd,wBAAoD,mBAAGA,WAAW,KAAQ,CACtE,KAAQ,+BADwC,iBAApD,qO,6MAQNL,EAAWM,gBAAiB","file":"component---src-docs-docs-type-compatibility-mdx-53735517dccc6a992203.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/packages/docs/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nimport { Schema } from \"./schemas/schema\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"type-compatibility\"\n    }}>{`Type Compatibility`}</h1>\n    <hr></hr>\n    <p>{`The Hegel are trying to implement type safity in JavaScript via strong type system. It means that analyzer ensure that a variable value always assignable to declarated (or inferenced) static type.`}</p>\n    <h2 {...{\n      \"id\": \"which-type-is-assignable-to-another\"\n    }}>{`Which type is assignable to another?`}</h2>\n    <p>{`In Hegel are presented the next hierarchy.`}</p>\n\n    <Schema type=\"hierarchy\" mdxType=\"Schema\" />\n    <p>{`This hierachy define rules of subtyping: \"Every type which is higher in the hierarchy will be a super type for current type\". Lets discover it by examples.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Tuple Type\nconst tuple: [number, number] = [42, 24]; // ðŸ‘Œ!\n\n// This is also an Array\nconst array: Array<number> = [42, 24];    // ðŸ‘Œ!\n\n// This is also an Object\nconst object: Object = [42, 24];          // ðŸ‘Œ!\n\n// This is also \"unknown\"\nconst unknown: unknown = [42, 24];        // ðŸ‘Œ!\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// But not in reverse order \n// Object is not a Tuple\n// Error: Type \"Object\" is incompatible with type \"[number, number]\"\nconst tuple: [number, number] = new Object();\n\n// And object is not a Array\n// Error: Type \"Object\" is incompatible with type \"Array<number>\"\nconst array: Array<number> = new Object();\n\n// But object is Object\nconst object: Object = new Object();\n\n// And object is unknown\nconst unknown: unknown = new Object();\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"function-types-compatibility\"\n    }}>{`Function types Compatibility`}</h2>\n    <p>{`Functions are not create any hierarhy. Compatibility of two functions defined by the rule:\nyou can assign function to another only if actual arguments types wider then declarated and return type is more specific then declarated. This rule sounds like: function is `}<a parentName=\"p\" {...{\n        \"href\": \"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\"\n      }}>{`contravariant`}</a>{` by arguments and `}<a parentName=\"p\" {...{\n        \"href\": \"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\"\n      }}>{`covariant`}</a>{` by return.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`let func: (number) => number = () => 42; \n\nfunc = (a: number): number => a;           // ðŸ‘Œ!\n// It's okay because \"number | string\" is wider than \"number\"\nfunc = (a: number | string): number => 44; // ðŸ‘Œ!\n// It's okay because \"42\" is more specific than \"number\"\nfunc = (a: number): 42 => 42;              // ðŸ‘Œ!\n// Error: Type \"(42) => number\" is incompatible with type \"(number) => number\"\n// Because \"42\" is more specific than \"number\"\nfunc = (a: 42): number => 42; \n// Error: Type \"(number) => number | string\" is incompatible with type \"(number) => number\"\n// Because \"number | string\" is wider than \"number\"\nfunc = (a: number): number | string => 42; \n`}</code></pre>\n    <h2 {...{\n      \"id\": \"generics-compatibility\"\n    }}>{`Generics Compatibility`}</h2>\n    <p>{`Two generic may be contained in hierarchy of each other only if their actual type parameter is in heierarchy of each other. For example, imagine generic container class:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typecript\"\n      }}>{`class Container<T> {\n  value: T;\n\n  constructor(value) {\n      this.value = value;\n  }\n}\n`}</code></pre>\n    <p>{`We can see a the same subtyping behaivour as with primitive types:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const wrapped42: Container<42> = new Container<42>(42);         // ðŸ‘Œ!\nconst wrappedNumber: Container<number> = new Container<42>(42); // ðŸ‘Œ!\n\n// Error: Type \"Container<number>\" is incompatible with type \"Container<42>\"\nconst wrappedNumber42: Container<42> = new Container<number>(84);\n// Error: Type \"Container<number>\" is incompatible with type \"Container<'Hello, World'>\"\nconst wrappedHelloWorld: Container<\"Hello, World\"> = new Container<number>(42);\n`}</code></pre>\n    <p>{`It's because `}<inlineCode parentName=\"p\">{`Container`}</inlineCode>{` type parameters is contained in hierarchy of each other.`}</p>\n    <p>{`But, as you can see, only literals were used for examples. It's because every subtype of Object in JavaScript act not like a value but like a \"poiter\" at value. So, for all reference types you can't do assign between variables if variables have not the same type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const wrapped42: Container<42> = new Container<42>(42); // ðŸ‘Œ!\n// Error: Type \"Container<42>\" is incompatible with type \"Container<number>\"\nconst wrappedNumber: Container<number> = wrapped42;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"soundness\"\n    }}>{`Soundness`}</h2>\n    <p>{`Soundness is ability of system to guarantee that after analysis your program will not be in invalid state. `}</p>\n    <p>{`Hegel try to implement the same soundness type system as `}<a parentName=\"p\" {...{\n        \"href\": \"https://reasonml.github.io/\"\n      }}>{`ReasonML/OCaml`}</a>{`, `}<a parentName=\"p\" {...{\n        \"href\": \"https://www.haskell.org/\"\n      }}>{`Haskell`}</a>{`, `}<a parentName=\"p\" {...{\n        \"href\": \"https://elm-lang.org/\"\n      }}>{`Elm`}</a>{` and other ML\n-based languages. It means Hegel try to catch every single error that might happen at runtime without runtime type checking.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`If you familiar with `}<a parentName=\"p\" {...{\n          \"href\": \"https://www.rust-lang.org/\"\n        }}>{`Rust Language`}</a>{` you may know that Rust doesn't provide any type information in runtime and all types will be stripped after type checking, but Rust program still type safe. It's our dream to implement the same type checking in JavaScript.`}</p>\n    </blockquote>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}