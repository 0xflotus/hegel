{"version":3,"sources":["webpack:///../src/docs/docs/array-types.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"kcAMO,IAAMA,EAAe,Q,+MAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,eADR,eAGA,uBACA,8QACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,wBADZ,gDAIL,8BACE,iBAAGA,WAAW,cAAd,+LAA2N,0BAAYA,WAAW,KAAvB,MAA3N,mDACA,mBAAKA,WAAW,cAAa,sBAAMA,WAAW,OAAU,CACpD,UAAa,wBADY,wFAK7B,iBAAGA,WAAW,cAAd,sFAEF,iBAAQ,CACN,GAAM,qBADR,qBAGA,8EACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,2FAKL,kJAAiI,0BAAYA,WAAW,KAAvB,SAAjI,6CACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6SAYL,8OACA,8BACE,iBAAGA,WAAW,cAAd,iJAA6K,mBAAGA,WAAW,KAAQ,CAC/L,KAAQ,iTADiK,sBAA7K,KAEqC,mBAAGA,WAAW,KAAQ,CACvD,KAAQ,4RADyB,mBAFrC,MAMF,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mNAUL,iBAAQ,CACN,GAAM,8BADR,8BAGA,2IACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,4HAML,8BACE,iBAAGA,WAAW,cAAd,+EAA2G,0BAAYA,WAAW,KAAvB,gBAA3G,OAA2K,0BAAYA,WAAW,KAAvB,UAA3K,8CACJ,mBAAGA,WAAW,KAAQ,CACd,KAAQ,mPADhB,sBADI,KAGqC,mBAAGA,WAAW,KAAQ,CACvD,KAAQ,mOADyB,mBAHrC,MAOF,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,gJAML,gMAC4I,mBAAGA,WAAW,KAAQ,CAC9J,KAAQ,gCADgI,UAD5I,sCAIA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,2MAUL,8BACE,iBAAGA,WAAW,cAAd,0KACJ,mBAAGA,WAAW,KAAQ,CACd,KAAQ,0VADhB,sBADI,KAGqC,mBAAGA,WAAW,KAAQ,CACvD,KAAQ,yUADyB,qBAIvC,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kPAUL,8BACE,iBAAGA,WAAW,cAAd,4DAAwF,0BAAYA,WAAW,KAAvB,UAAxF,6HACA,mBAAKA,WAAW,cAAa,sBAAMA,WAAW,OAAU,CACpD,UAAa,wBADY,2BAI7B,iBAAGA,WAAW,cAAd,0DAEF,uGAAsF,0BAAYA,WAAW,KAAvB,WAAtF,4CAAsL,0BAAYA,WAAW,KAAvB,OAAtL,KAA2O,0BAAYA,WAAW,KAAvB,UAA3O,6DACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,uGAML,iBAAQ,CACN,GAAM,aADR,aAGA,qKACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,gMAOL,8BACE,iBAAGA,WAAW,cAAd,wLAEF,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6PAUL,8BACE,iBAAGA,WAAW,cAAd,yEAAqG,mBAAGA,WAAW,KAAQ,CACvH,KAAQ,4UADyF,yB,sMAQ3GJ,EAAWK,gBAAiB","file":"component---src-docs-docs-array-types-mdx-678d1e922abc34ac0999.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/packages/docs/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"array-types\"\n    }}>{`Array Types`}</h1>\n    <hr></hr>\n    <p>{`Array is another fundamental JavaScript data type which represents a heterogeneous collection (collection which can contain more than one data-type inside). Hegel provides syntax for annotatation array type and restricts collection element type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`If you are familiar with TypeScript or Flow.js, you may know about array types, but both Flow.js and TypeScript provide two ways for array definition: via Array-constructor and via adding `}<inlineCode parentName=\"p\">{`[]`}</inlineCode>{` (squere brackets) at the end of the type name:`}</p>\n      <pre parentName=\"blockquote\"><code parentName=\"pre\" {...{\n          \"className\": \"language-typescript\"\n        }}>{`const oneWay: Array<number> = [1, 2, 3];\nconst anotherOne: number[] = [1, 2, 3];\n`}</code></pre>\n      <p parentName=\"blockquote\">{`Hegel provides only first variant without additional syntax with squere brackets.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"array-constructor\"\n    }}>{`Array Constructor`}</h2>\n    <p>{`JavaScript has two different ways to define an array.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const arrayLiteral = [];\nconst arrayConstructorInvocationWithLength = new Array(0);\n`}</code></pre>\n    <p>{`And Hegel has a difference for this two JavaScript ways of array definition. The difference is: when you create array via `}<inlineCode parentName=\"p\">{`Array`}</inlineCode>{` constructor - array will be \"undefined\".`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const arrayLiteral: Array<number> = [];\narrayLiteral[0] = 4;         // ðŸ‘Œ!\n\n// Error: Type \"undefined\" is incompatible with type \"number\"\narrayLiteral[1] = undefined;\n\nconst arrayInstance = new Array<number>(4);\narrayInstance[0] = 4;         // ðŸ‘Œ!\narrayInstance[1] = undefined; // ðŸ‘Œ!\n`}</code></pre>\n    <p>{`The reason of this decision is behaivour of Array instance. Even if you set length of you array it will be filled with undefined, so Hegel can't give any guarantees that all your elements will have annotated type.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`TypeScript and Flow.js have not differenced for this difference array creation way, so it's easy to get runtime TypeError with this analyzers `}<a parentName=\"p\" {...{\n          \"href\": \"https://www.typescriptlang.org/v2/en/play?ts=3.8.0-beta#code/MYewdgzgLgBAhgJwXAngSUlOZgFMYC8MYuA7jAIJKoA8YArgLYBGuCAfABQAsAlANwAoQQBtcsAJZgoAZVwBHerhz4iAIjVCAZiAQxOoTMSYwQW+NXSZseXjADegmDAD0LmABUUAB1wBRJF0ALhgAYWwwEFgEXDgAExhvBBBfBCgUGAByKBAAMQkAD1w4zNNzejA43C0pYqcYKVkFJRUYAGoiBkYAOhz8orjOAAYBQQBfIA\"\n        }}>{`TypeScript Example`}</a>{`, `}<a parentName=\"p\" {...{\n          \"href\": \"https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoAxnAdgZwC5gCGATsYQJ4CSuehW6ApmALxhYNICCpFAPFgFcAtgCMGxAHwAKACwBKANypUMBgQCWWPAGUGARwEN6TVgCJTSqHGJgpmGm2Fg4UIjyo06jOWADeqMDBgYDAAFXIABwYAUVJrAC4wAGE6LDgCYgZCABMwCOI4KOI8cjAAcjw4ADF1AA8GbLLnVwEsbIYoTQaAsE0dfUNjMABqVkEhADpKmvrsqQAGRVQAXyA\"\n        }}>{`Flow.js Example`}</a>{`:`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const arrayInstance = new Array<number>(4);\n\nlet intSequence = \"\";\nfor (const num of arrayInstance) {\n  // TypeError: Cannot read property 'toFixed' of undefined\n  intSequence += num.toFixed(0);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"getting-element-from-array\"\n    }}>{`Getting element from Array`}</h2>\n    <p>{`Another interesting Hegel \"feature\" is type inference for element which will be gotten from array by index syntax.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [];\n// Type of firstElement is \"number | undefined\"\nconst firstElement = numbers[0];\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`If you are familiar with TypeScript or Flow.js, this \"analyzers\" will infer `}<inlineCode parentName=\"p\">{`firstElement`}</inlineCode>{` as `}<inlineCode parentName=\"p\">{`number`}</inlineCode>{` which can create a TypeError in runtime.\n`}<a parentName=\"p\" {...{\n          \"href\": \"https://www.typescriptlang.org/v2/en/play?ts=3.8.0-beta#code/MYewdgzgLgBGCuBbARgUwE4QFwwILvQEMBPAHgRQwD4YBeGAbQF0BuAKAHoOYAVYgB1QBRAiHQ4AwoTBgQsdKkIATGP3QhB6KMRgByKCABiASwAeqJbpggAZjHhglqG8bAW2oSLBeYoQgDaoiKhgsPQUaJgMAAxMAHQGJuZKABQAlCxAA\"\n        }}>{`TypeScript Example`}</a>{`, `}<a parentName=\"p\" {...{\n          \"href\": \"https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVBjOA7AzgFzGwFcBbAIwFMAnXALjAEFrqBDATwB4SKaA+MAF4wAbQC6AblTBgYACrsADpQCiLONQYBhVtmxxC1SqwAmYRdTjLq+dmADk+OADEAlgA9KJ+2DhQwxNgmlFCu2F6YOARgobT4KjCUpJTYhMI8VLQiAAxiAHRObp4mABQAlFJAA\"\n        }}>{`Flow.js example`}</a>{`.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [];\n// TypeError: Cannot read property 'toFixed' of undefined\nconst firstElement = numbers[0].toFixed();\n`}</code></pre>\n    <p>{`Let's go back to Hegel.\nThis behaivour also means that even if you try access an element in for loop you still get \"number | undefined\" element type. And you need to `}<a parentName=\"p\" {...{\n        \"href\": \"/hegel/docs/type-refinement\"\n      }}>{`refine`}</a>{` that your value is not undefined.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\nfor (let i = 0; i < numbers.length; i++) {\n  const num = numbers[i]; // still \"number | undefined\"\n  if (typeof num === \"number\") {\n    // ...\n  }\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The reason of this decision is a mutable nature of \"length\" property of Array, so I can write next code, which will break my program without this property behaviour.\n`}<a parentName=\"p\" {...{\n          \"href\": \"https://www.typescriptlang.org/v2/en/play?ts=3.8.0-beta#code/MYewdgzgLgBGCuBbARgUwE4QFwwILvQEMBPAHgRQwD4YBeGAbQEYAaGAJjYGYBdAbgBQAG1SwAlmCgBlVAEd4qMMFR0YAIjWCKaTADoRYAOZQAFqoCsggGYh0MABQjxqgAx8YYmKThIdEfYrGJu5iANShAJQwAN4CMDAA9AkwACrEAA6oAKIEtjgAwoRgYCCw6KiEACYw6eggmehQxDAA5FAgAGJiAB6olS0wIFYw8GCVqFYSfXEekjLyisowofTaGBAMYjy67V29lfYRggC+AkA\"\n        }}>{`TypeScript example`}</a>{`, `}<a parentName=\"p\" {...{\n          \"href\": \"https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoAxnAdgZwC5hYCuAtgEYCmATjgFxgCCVVAhgJ4A8x51AfGAF4wAbQCMAGjAAmSQGYAugG5UMCgQCWWPAGUKARyIUs6CoLAAic8u6UaAOlVYA5ngAWZgKzKocKmAAUqhpmAAyKYOpgHISktjgORi6u4eoA1KkAlGAA3qhgYMDAYAAqbAAOFACizL70AMIsWFhwBFQULAAmYGVUcBVUeGxgAOR4cABi6gAeFB3DYHBQYERYHRRQmrN5EVq6BkYmYKlCNtQ4wurydmOTMx3+GcoAvqhAA\"\n        }}>{`Flow.js Example`}</a></p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\nlet intSequence = \"\";\nnumbers.length = 5;\nfor (let i = 0; i < numbers.length; i++) {\n  // TypeError: Cannot read property 'toFixed' of undefined\n  intSequence += numbers[i].toFixed();\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Why do not make length 'readonly' and add refinement for `}<inlineCode parentName=\"p\">{`length`}</inlineCode>{` array property?\". And the answer is a popular way for array clean. In many JavaScript program you may see the next line:`}</p>\n      <pre parentName=\"blockquote\"><code parentName=\"pre\" {...{\n          \"className\": \"language-typescript\"\n        }}>{`someArray.length = 0\n`}</code></pre>\n      <p parentName=\"blockquote\">{`This is the most popular way for fast array cleaning.`}</p>\n    </blockquote>\n    <p>{`For nowadays this is not JavaScript-way to iterate over the array. You can use `}<inlineCode parentName=\"p\">{`forEach`}</inlineCode>{` (or other additional array methods like `}<inlineCode parentName=\"p\">{`map`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`filter`}</inlineCode>{` and etc.) as a safe variant of iterating over the array.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\n// num type is \"number\"\nnumbers.forEach(num => { });\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"subtyping\"\n    }}>{`Subtyping`}</h2>\n    <p>{`Another safety part of Hegel Arrays is their invariant nature. You can't assign one array to another if they contain different element type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\n\n// Error: Type \"Array<number>\" is incompatible with type \"Array<number | string>\"\nconst numbersOrStrings: Array<number | string> = numbers;\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The reason of this decision is a reference nature of JavaScript array. If Hegel allows this assign you will be able mutate source array via another and get unpredictable problems.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\nconst numbersOrStrings: Array<number | string> = numbers;\n\nnumbersOrStrings.push(\"some string\");\n\n// TypeError: num.toFixed is not a function\nconst fixedNumbers = numbers.map(num => num.toFixed(0));\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`If you are familiar with TypeScript, you may know about this problem. `}<a parentName=\"p\" {...{\n          \"href\": \"http://www.typescriptlang.org/play/index.html?ssl=1&ssc=1&pln=8&pc=1#code/MYewdgzgLgBGCuBbARgUwE4QFwwILvQEMBPAHgRQwD4YBeGAbQEYAaGAJjYGYBdAbgBQoSLAppMAeXQBlKOgCWYAObY8BEuSTiYAHxjQFymvTEYIggacky5ilQDoADvAgALABQAiCCESp9tsqeAJQWAPRhMAAqxI6oAKIEIOg4FPZQIABi8gAeqAAmMPIQcCCwhDAAZvBgwFDy4ELg0FW5BQByWmZ0cF2Y9oiEju4UdDRpGdl5+e4ADMGhAkA\"\n        }}>{`TypeScript Example`}</a></p>\n    </blockquote>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}